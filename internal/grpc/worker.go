
package grpc

import (
	"context"

	"github.com/equinor/vds-slice/internal/vds"
)

// Simple temporary azure connection to satisfy vds.NewHandle's API. Assumes
// everything is fine and does a straight pass-through of the variables.
// Sanitation should happend on the scheduler side and the workers should assume
// that these are correctly formatted for openVDS.
type AzureConnection struct {
	url string
	connection string
}

func (c *AzureConnection) Url() string { 
	return c.url
}

func (c *AzureConnection) ConnectionString() string { 
	return c.connection
}

func (c *AzureConnection) IsAuthorizedToRead() bool { 
	return false
}

func NewAzureConnection(url, connection string) (*AzureConnection) {
	return &AzureConnection{url: url, connection: connection}
}

/* Our gRPC server
 *
 * Implementation of our remote procedure calls.
 */
type Worker struct {
	// auto-generated by protoc
	UnimplementedOneseismicServer
}

func (w *Worker) GetFence(
	ctx context.Context,
	req *FenceRequest,
) (*FenceResponse, error) {
	logmsg(req.Info, "Processing request...")

	conn := NewAzureConnection(req.Connection.Url, req.Connection.Credential)
	handle, err := vds.NewVDSHandle(conn)
	if err != nil { 
		return nil, err
	}
	defer handle.Close()

	coords := make([][]float32, len(req.Coordinates))
	for i, coordinate := range req.Coordinates {
		coords[i] = []float32{ coordinate.X, coordinate.Y }
	}

	fence, err := handle.GetFence(
		int(req.CoordinateSystem),
		coords,
		int(req.Interpolation),
	)
	if err != nil { 
		return nil, err
	}

	logmsg(req.Info, "Request done!")
	return &FenceResponse{ Fence: fence, Info: req.Info }, err
}

